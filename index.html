<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Run AJ Run! - Escape the Office</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --ui-font: 'Courier New', Courier, monospace;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: #fff;
            font-family: var(--ui-font);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 4px solid #444;
            image-rendering: pixelated;
            cursor: pointer;
            background-color: #222;
            max-width: 95vw;
        }

        canvas {
            display: block;
            image-rendering: -moz-crisp-edges;
            image-rendering: pixelated;
            max-width: 100%;
            height: auto;
        }

        #mobile-controls {
            display: none;
            grid-template-areas: 
                ". u ."
                "l d r";
            gap: 10px;
            margin-top: 20px;
        }

        .d-btn {
            width: 60px;
            height: 60px;
            background: #555;
            border: 4px solid #eee;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            user-select: none;
            touch-action: none;
            border-radius: 8px;
        }

        .d-btn:active {
            background: #888;
        }

        @media (pointer: coarse) {
            #mobile-controls {
                display: grid;
            }
        }

        #ui-overlay {
            position: absolute;
            top: 5px;
            left: 5px;
            right: 5px;
            pointer-events: none;
            text-transform: uppercase;
            font-weight: bold;
            font-size: 11px;
            display: none;
            justify-content: space-between;
            z-index: 20;
            color: #fff;
        }

        .ui-segment {
            background: rgba(0, 0, 0, 0.6);
            padding: 4px 8px;
            border-radius: 4px;
            text-shadow: 1px 1px #000;
            border: 1px solid rgba(255, 255, 255, 0.2);
            white-space: nowrap;
        }

        #progress-container {
            position: absolute;
            bottom: 5px;
            left: 10px;
            right: 10px;
            height: 6px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #fff;
            display: none;
            z-index: 10;
        }

        #progress-bar {
            height: 100%;
            width: 0%;
            background: #2ecc71;
            transition: width 0.1s linear;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="ui-overlay">
            <div id="floor-display" class="ui-segment">FLOOR: 5</div>
            <div id="lives-display" class="ui-segment" style="color: #e74c3c">LIVES: 3</div>
            <div id="score-display" class="ui-segment">POINTS: 0000</div>
        </div>
        <div id="progress-container">
            <div id="progress-bar"></div>
        </div>
    </div>

    <div id="mobile-controls">
        <div class="d-btn" style="grid-area: u" id="btn-up">▲</div>
        <div class="d-btn" style="grid-area: l" id="btn-left">◀</div>
        <div class="d-btn" style="grid-area: d" id="btn-down">▼</div>
        <div class="d-btn" style="grid-area: r" id="btn-right">▶</div>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false }); 
const floorDisplay = document.getElementById('floor-display');
const livesDisplay = document.getElementById('lives-display');
const scoreDisplay = document.getElementById('score-display');
const uiOverlay = document.getElementById('ui-overlay');
const progressContainer = document.getElementById('progress-container');
const progressBar = document.getElementById('progress-bar');

const INTERNAL_W = 160;
const INTERNAL_H = 240;
const SCALE = 3; 

canvas.width = INTERNAL_W * SCALE;
canvas.height = INTERNAL_H * SCALE;
ctx.scale(SCALE, SCALE);
ctx.imageSmoothingEnabled = false;

const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

// --- SOUND ENGINE (Web Audio API) ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    const now = audioCtx.currentTime;

    switch(type) {
        case 'walk':
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(60, now);
            osc.frequency.exponentialRampToValueAtTime(10, now + 0.05);
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.05);
            osc.start(now);
            osc.stop(now + 0.05);
            break;
        case 'pickup':
            osc.type = 'square';
            osc.frequency.setValueAtTime(440, now);
            osc.frequency.exponentialRampToValueAtTime(880, now + 0.1);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
            break;
        case 'coffee':
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(523.25, now); // C5
            osc.frequency.exponentialRampToValueAtTime(1046.50, now + 0.2); // C6
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
            break;
        case 'floppy':
            osc.type = 'square';
            [0, 0.05, 0.1].forEach((t, i) => {
                const f = 600 + (i * 200);
                osc.frequency.setValueAtTime(f, now + t);
            });
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
            break;
        case 'hit':
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(40, now + 0.3);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.3);
            osc.start(now);
            osc.stop(now + 0.3);
            break;
        case 'start':
            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
            break;
        case 'clear':
            osc.type = 'square';
            osc.frequency.setValueAtTime(523, now);
            osc.frequency.setValueAtTime(659, now + 0.1);
            osc.frequency.setValueAtTime(783, now + 0.2);
            osc.frequency.setValueAtTime(1046, now + 0.3);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.5);
            osc.start(now);
            osc.stop(now + 0.5);
            break;
    }
}

let lastTime = Date.now();

const state = {
    screen: 'START', 
    floor: 5,
    score: 0,
    lives: 3,
    floorScore: 0,
    distance: 0,
    maxDistance: 60000, 
    gameOverMessage: "",
    introTimer: 0,
    player: {
        x: INTERNAL_W / 2 - 6,
        y: INTERNAL_H - 60,
        w: 12,
        h: 16,
        speed: 100, 
        frame: 0,
        animTimer: 0,
        walkSoundTimer: 0, // Timer for walking SFX
        powerup: null,
        powerupTimer: 0,
        trail: [] 
    },
    finishLineY: -500, 
    doorX: INTERNAL_W / 2 - 15,
    doorY: -800, 
    obstacles: [],
    pickups: [],
    floatingTexts: [], 
    keys: {},
    swipeTrail: [], 
    touchStart: null,
    floorConfig: {
        5: { name: "TOP FLOOR OFFICE", speed: 50, spawnRate: 0.015, color: '#556677' },
        4: { name: "OPEN PLAN HELL", speed: 65, spawnRate: 0.022, color: '#667755' },
        3: { name: "MANAGEMENT LABYRINTH", speed: 80, spawnRate: 0.030, color: '#775555' },
        2: { name: "HR DUNGEON", speed: 95, spawnRate: 0.038, color: '#555577' },
        1: { name: "GROUND FLOOR EXIT", speed: 110, spawnRate: 0.045, color: '#333333' }
    },
    hazardMessages: {
        'MEETING': [
            "STUCK IN AN AD-HOC MEETING",
            "TRAPPED BY A 'QUICK CHAT'",
            "CAUGHT IN A STEERING GROUP",
            "MANDATORY DIAL-IN DELAY"
        ],
        'NOTIF': [
            "CAUGHT IN A MS TEAMS LOOP",
            "INFINITE PINGS FROM MS TEAMS",
            "CAUGHT OUT BY FAKE PHISH EMAIL",
            "NOTIFIED TO DEATH"
        ],
        'SLIDES': [
            "DEATH BY POWERPOINT",
            "STORYBOARD REVISION HELL",
            "SCORM COMPLIANCE ERROR",
            "CLIENT FEEDBACK OVERLOAD"
        ]
    }
};

// --- DRAWING ---

function drawRect(x, y, w, h, color) {
    ctx.fillStyle = color;
    ctx.fillRect(Math.floor(x), Math.floor(y), Math.floor(w), Math.floor(h));
}

function drawOutlined(x, y, drawFn, outlineColor) {
    const silhouette = (sx, sy) => {
        const tempDrawRect = window.drawRect;
        window.drawRect = (rx, ry, rw, rh, c) => {
            ctx.fillStyle = outlineColor;
            ctx.fillRect(Math.floor(rx), Math.floor(ry), Math.floor(rw), Math.floor(rh));
        };
        drawFn(sx, sy);
        window.drawRect = tempDrawRect;
    };

    silhouette(x - 1, y);
    silhouette(x + 1, y);
    silhouette(x, y - 1);
    silhouette(x, y + 1);

    drawFn(x, y);
}

function drawPlayerSprite(x, y, frame) {
    const f = Math.floor(frame) % 2;
    drawRect(x+3, y, 6, 7, '#ffdbac'); // Head
    drawRect(x+3, y+5, 6, 2, '#d35400'); // Tie
    drawRect(x+2, y+7, 8, 5, '#2980b9'); // Suit
    if (f === 0) { 
        drawRect(x+2, y+12, 3, 4, '#34495e'); 
        drawRect(x+7, y+11, 3, 3, '#34495e'); 
    } else { 
        drawRect(x+2, y+11, 3, 3, '#34495e'); 
        drawRect(x+7, y+12, 3, 4, '#34495e'); 
    }
}

function drawPlayer(p) {
    if (p.powerup === 'COFFEE') {
        p.trail.forEach((t, i) => {
            ctx.globalAlpha = (i / p.trail.length) * 0.4;
            drawPlayerSprite(t.x, t.y, t.frame);
        });
        ctx.globalAlpha = 1.0;
    }

    if (p.powerup === 'ANNUAL LEAVE' && Math.floor(Date.now()/100) % 2 === 0) {
        drawOutlined(p.x, p.y, (sx, sy) => drawPlayerSprite(sx, sy, p.frame), '#f1c40f');
    } else {
        drawPlayerSprite(p.x, p.y, p.frame);
    }
}

function drawMeetingSprite(x, y) {
    drawRect(x+4, y+4, 20, 10, '#5d4037'); 
    drawRect(x+5, y+5, 18, 8, '#795548'); 
    drawRect(x+10, y+7, 3, 4, '#fff');
    drawRect(x+16, y+8, 2, 2, '#fff');
    drawRect(x+1, y+5, 3, 3, '#34495e'); 
    drawRect(x+1, y+8, 3, 3, '#34495e');
    drawRect(x+24, y+5, 3, 3, '#34495e'); 
    drawRect(x+24, y+8, 3, 3, '#34495e');
    drawRect(x+8, y+1, 3, 3, '#34495e');
    drawRect(x+13, y+1, 3, 3, '#34495e');
    drawRect(x+18, y+1, 3, 3, '#34495e');
}

function drawNotificationSprite(x, y) {
    drawRect(x+2, y+2, 12, 10, '#f39c12'); 
    drawRect(x+4, y+12, 3, 2, '#f39c12');
    drawRect(x+7, y+4, 2, 6, '#fff');
}

function drawSlideDeckSprite(x, y) {
    drawRect(x, y, 16, 12, '#bdc3c7'); 
    drawRect(x+1, y+1, 14, 10, '#fff');
    drawRect(x+3, y+7, 2, 3, '#2ecc71');
    drawRect(x+6, y+4, 2, 6, '#f1c40f');
    drawRect(x+9, y+2, 2, 8, '#e74c3c');
    drawRect(x+7, y+12, 2, 4, '#333');
    drawRect(x+4, y+16, 8, 2, '#333');
}

function drawMeeting(x, y) { drawOutlined(x, y, drawMeetingSprite, '#ff0000'); }
function drawNotification(x, y) { drawOutlined(x, y, drawNotificationSprite, '#ff0000'); }
function drawSlideDeck(x, y) { drawOutlined(x, y, drawSlideDeckSprite, '#ff0000'); }
function drawCoffee(x, y) {
    drawRect(x+2, y, 8, 10, '#fff'); 
    drawRect(x+10, y+2, 2, 4, '#fff'); 
    drawRect(x+3, y+2, 6, 2, '#6f4e37'); 
}
function drawLeave(x, y) {
    drawRect(x, y, 16, 12, '#f1c40f'); 
    drawRect(x+2, y+2, 12, 8, '#d4ac0d'); 
}
function drawFloppy(x, y) {
    drawRect(x, y, 14, 14, '#34495e');
    drawRect(x+2, y+1, 10, 4, '#ecf0f1');
    drawRect(x+4, y+9, 6, 5, '#bdc3c7');
}

function drawFinishLine(y) {
    const size = 10;
    for(let x=0; x<INTERNAL_W; x+=size) {
        ctx.fillStyle = (Math.floor(x/size) % 2 === 0) ? '#fff' : '#000';
        ctx.fillRect(x, Math.floor(y), size, 5);
        ctx.fillStyle = (Math.floor(x/size) % 2 === 0) ? '#000' : '#fff';
        ctx.fillRect(x, Math.floor(y)+5, size, 5);
    }
}

function drawDoor(y) {
    const dx = state.doorX;
    drawRect(dx, y, 30, 45, '#3e2723'); 
    drawRect(dx+2, y+2, 26, 41, '#5d4037'); 
    drawRect(dx+24, y+20, 3, 3, '#f1c40f'); 
    ctx.fillStyle = '#000';
    ctx.font = 'bold 6px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('EXIT', dx+15, y+12);
}

function addFloatingText(x, y, text, color = '#2ecc71') {
    state.floatingTexts.push({ x, y, text, color, life: 1.0 });
}

// --- LOGIC ---

function checkOverlap(x, y, w, h) {
    const padding = 8; 
    for (const o of state.obstacles) {
        if (x < o.x + o.w + padding && x + w + padding > o.x && y < o.y + o.h + padding && y + h + padding > o.y) return true;
    }
    for (const pk of state.pickups) {
        if (x < pk.x + pk.w + padding && x + w + padding > pk.x && y < pk.y + pk.h + padding && y + h + padding > pk.y) return true;
    }
    return false;
}

function spawnEntities(dt) {
    const config = state.floorConfig[state.floor];
    if (state.distance > state.maxDistance - 800) return; 

    if (Math.random() < config.spawnRate * (dt * 60)) {
        const types = ['MEETING', 'NOTIF', 'SLIDES'];
        const type = types[Math.floor(Math.random()*types.length)];
        const w = type === 'MEETING' ? 28 : 16;
        const h = type === 'MEETING' ? 15 : (type === 'SLIDES' ? 20 : 16);
        const x = Math.max(2, Math.min(INTERNAL_W - w - 2, Math.random() * INTERNAL_W));
        if (!checkOverlap(x, -30, w, h)) state.obstacles.push({ x, y: -30, w, h, type });
    }
    
    if (Math.random() < 0.007 * (dt * 60)) {
        const r = Math.random();
        let type = 'COFFEE';
        if (r > 0.65) type = 'ANNUAL LEAVE';
        if (r > 0.85) type = 'FLOPPY';
        
        const w = 16;
        const x = Math.max(2, Math.min(INTERNAL_W - w - 2, Math.random() * INTERNAL_W));
        if (!checkOverlap(x, -30, w, 14)) state.pickups.push({ x, y: -30, w, h: 14, type });
    }
}

function update() {
    const now = Date.now();
    const dt = (now - lastTime) / 1000;
    lastTime = now;

    const config = state.floorConfig[state.floor];
    const p = state.player;

    if (p.powerup === 'COFFEE') {
        p.trail.push({ x: p.x, y: p.y, frame: p.frame });
        if (p.trail.length > 8) p.trail.shift();
    } else if (p.trail.length > 0) {
        p.trail.shift();
    }

    for (let i = state.swipeTrail.length - 1; i >= 0; i--) {
        state.swipeTrail[i].life -= 120 * dt; 
        if (state.swipeTrail[i].life <= 0) state.swipeTrail.splice(i, 1);
    }

    for (let i = state.floatingTexts.length - 1; i >= 0; i--) {
        state.floatingTexts[i].life -= dt;
        state.floatingTexts[i].y -= 20 * dt; 
        if (state.floatingTexts[i].life <= 0) state.floatingTexts.splice(i, 1);
    }

    p.animTimer += dt;
    const animThreshold = p.powerup === 'COFFEE' ? 0.06 : 0.12;
    if (p.animTimer > animThreshold) {
        p.frame++;
        p.animTimer = 0;
    }

    if (state.screen === 'INTRO_FLOOR') {
        state.introTimer -= dt;
        if (state.introTimer <= 0) {
            state.screen = 'PLAY';
        }
        return;
    }

    if (state.screen === 'FINISH_SEQ') {
        p.y -= 70 * dt; 
        const targetX = state.doorX + 9;
        if (p.x < targetX) p.x += 40 * dt;
        if (p.x > targetX) p.x -= 40 * dt;

        // Walking sound during sequence
        p.walkSoundTimer -= dt;
        if (p.walkSoundTimer <= 0) {
            playSound('walk');
            p.walkSoundTimer = 0.25;
        }

        if (p.y < state.doorY + 20) {
            playSound('clear');
            state.screen = 'CLEARED';
        }
        return;
    }

    if (state.screen === 'HIT_PAUSE') {
        return;
    }

    if (state.screen !== 'PLAY') return;

    let dx = 0, dy = 0;
    if (state.keys['ArrowLeft'] || state.keys['a']) dx -= 1;
    if (state.keys['ArrowRight'] || state.keys['d']) dx += 1;
    if (state.keys['ArrowUp'] || state.keys['w']) dy -= 1;
    if (state.keys['ArrowDown'] || state.keys['s']) dy += 1;

    const speedMultiplier = p.powerup === 'COFFEE' ? 2.5 : 1.0;
    const isMoving = dx !== 0 || dy !== 0;
    
    if (isMoving) {
        if (dx !== 0 && dy !== 0) { dx *= 0.707; dy *= 0.707; }
        p.x += dx * p.speed * speedMultiplier * dt;
        p.y += dy * p.speed * speedMultiplier * dt;

        // Walking Sound logic
        p.walkSoundTimer -= dt;
        if (p.walkSoundTimer <= 0) {
            playSound('walk');
            // Faster steps when on coffee
            p.walkSoundTimer = p.powerup === 'COFFEE' ? 0.15 : 0.25;
        }
    } else {
        p.walkSoundTimer = 0; // Reset so sound plays immediately when starting to move
    }

    p.x = Math.max(0, Math.min(INTERNAL_W - p.w, p.x));
    p.y = Math.max(0, Math.min(INTERNAL_H - p.h, p.y));

    if (p.powerup) {
        p.powerupTimer -= dt;
        if (p.powerupTimer <= 0) p.powerup = null;
    }

    const scrollSpeed = config.speed * dt;
    state.distance += config.speed * 20 * dt; 
    
    state.score += Math.floor(scrollSpeed * 5);
    state.floorScore += Math.floor(scrollSpeed * 5);
    
    floorDisplay.innerText = `FLOOR: ${state.floor === 1 ? 'G' : state.floor}`;
    scoreDisplay.innerText = `POINTS: ${Math.floor(state.score).toString().padStart(4, '0')}`;
    livesDisplay.innerText = `LIVES: ${state.lives}`;

    const progress = Math.min(100, (state.distance / state.maxDistance) * 100);
    progressBar.style.width = `${progress}%`;

    if (state.distance > state.maxDistance - 1000) {
        state.finishLineY += scrollSpeed;
        state.doorY += scrollSpeed;
    }

    if (state.distance >= state.maxDistance && p.y <= state.finishLineY) {
        state.screen = 'FINISH_SEQ';
    }

    spawnEntities(dt);

    for (let i = state.obstacles.length - 1; i >= 0; i--) {
        const o = state.obstacles[i];
        o.y += scrollSpeed;
        if (p.x < o.x + o.w && p.x + p.w > o.x && p.y < o.y + o.h && p.y + p.h > o.y) {
            if (p.powerup !== 'ANNUAL LEAVE') {
                state.lives--;
                playSound('hit');
                const msgList = state.hazardMessages[o.type];
                state.gameOverMessage = msgList[Math.floor(Math.random() * msgList.length)];
                
                if (state.lives <= 0) {
                    state.screen = 'GAMEOVER';
                } else {
                    state.screen = 'HIT_PAUSE';
                    state.introTimer = 0;
                }
            }
        }
        if (o.y > INTERNAL_H) state.obstacles.splice(i, 1);
    }

    for (let i = state.pickups.length - 1; i >= 0; i--) {
        const pk = state.pickups[i];
        pk.y += scrollSpeed;
        if (p.x < pk.x + pk.w && p.x + p.w > pk.x && p.y < pk.y + pk.h && p.y + p.h > pk.y) {
            if (pk.type === 'COFFEE') { 
                state.score += 250; 
                state.floorScore += 250; 
                playSound('coffee');
                addFloatingText(p.x + p.w/2, p.y, "SPEED UP! +250", "#f39c12");
            } else if (pk.type === 'FLOPPY') { 
                state.score += 500; 
                state.floorScore += 500; 
                playSound('floppy');
                addFloatingText(p.x + p.w/2, p.y, "WORK BACKED UP! +500", "#3498db");
            } else if (pk.type === 'ANNUAL LEAVE') {
                state.score += 200;
                state.floorScore += 200;
                playSound('pickup');
                addFloatingText(p.x + p.w/2, p.y, "SHIELD! +200", "#f1c40f");
            }
            p.powerup = pk.type;
            p.powerupTimer = pk.type === 'FLOPPY' ? 1.5 : 5.0; 
            state.pickups.splice(i, 1);
        }
        if (pk.y > INTERNAL_H) state.pickups.splice(i, 1);
    }
}

function draw() {
    const config = state.floorConfig[state.floor];
    ctx.clearRect(0, 0, INTERNAL_W, INTERNAL_H);

    const activeGameScreens = ['PLAY', 'FINISH_SEQ', 'CLEARED', 'GAMEOVER', 'HIT_PAUSE'];
    uiOverlay.style.display = activeGameScreens.includes(state.screen) ? 'flex' : 'none';
    progressContainer.style.display = (state.screen === 'PLAY' || state.screen === 'FINISH_SEQ') ? 'block' : 'none';

    if (state.screen === 'START') {
        drawRect(0, 0, INTERNAL_W, INTERNAL_H, '#111');
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0, 40, INTERNAL_W, 60);
        ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.font = 'bold 14px monospace';
        ctx.fillText('RUN AJ RUN!', INTERNAL_W/2, 60);
        ctx.fillStyle = '#f1c40f'; ctx.font = 'bold 7px monospace';
        ctx.fillText('HELP AJ ESCAPE THE OFFICE', INTERNAL_W/2, 80);
        ctx.fillStyle = '#fff'; ctx.font = '8px monospace';
        ctx.fillText(isTouchDevice ? 'TAP TO START' : 'PRESS SPACE TO START', INTERNAL_W/2, 160);
        drawPlayerSprite(INTERNAL_W/2 - 6, 110, 0);
        return;
    }

    if (state.screen === 'HOWTO_PICKUPS') {
        drawRect(0, 0, INTERNAL_W, INTERNAL_H, '#1a1a1a');
        ctx.fillStyle = '#2ecc71'; ctx.fillRect(0, 10, INTERNAL_W, 25);
        ctx.fillStyle = '#000'; ctx.textAlign = 'center'; ctx.font = 'bold 14px monospace';
        ctx.fillText('OFFICE PERKS', INTERNAL_W/2, 28);
        ctx.textAlign = 'left'; ctx.font = '8px monospace';
        drawCoffee(15, 60); ctx.fillStyle = '#f39c12'; ctx.fillText('COFFEE', 40, 68);
        ctx.fillStyle = '#bdc3c7'; ctx.font = '6px monospace'; ctx.fillText('SPEED BOOST & +250 PTS', 40, 78);
        drawLeave(15, 100); ctx.fillStyle = '#f1c40f'; ctx.font = '8px monospace';
        ctx.fillText('ANNUAL LEAVE', 40, 108);
        ctx.fillStyle = '#bdc3c7'; ctx.font = '6px monospace'; ctx.fillText('SHIELD & +200 PTS', 40, 118);
        drawFloppy(15, 140); ctx.fillStyle = '#3498db'; ctx.font = '8px monospace'; ctx.fillText('FLOPPY DISK', 40, 148);
        ctx.fillStyle = '#bdc3c7'; ctx.font = '6px monospace'; ctx.fillText('BONUS +500 PTS', 40, 158);
        ctx.textAlign = 'center'; ctx.fillStyle = '#fff'; ctx.font = '7px monospace';
        ctx.fillText(isTouchDevice ? 'TAP FOR NEXT PAGE' : 'SPACE FOR NEXT PAGE', INTERNAL_W/2, 215);
        return;
    }

    if (state.screen === 'HOWTO_OBSTACLES') {
        drawRect(0, 0, INTERNAL_W, INTERNAL_H, '#1a1a1a');
        ctx.fillStyle = '#e74c3c'; ctx.fillRect(0, 10, INTERNAL_W, 25);
        ctx.fillStyle = '#000'; ctx.textAlign = 'center'; ctx.font = 'bold 14px monospace';
        ctx.fillText('WORK HAZARDS', INTERNAL_W/2, 28);
        ctx.textAlign = 'left'; ctx.font = '7px monospace';
        drawMeeting(10, 60); ctx.fillStyle = '#bdc3c7'; ctx.fillText('AD-HOC MEETING', 45, 70);
        drawNotification(15, 100); ctx.fillStyle = '#bdc3c7'; ctx.fillText('TEAMS PINGS', 45, 110);
        drawSlideDeck(15, 140); ctx.fillStyle = '#bdc3c7'; ctx.fillText('30-SLIDE DECK', 45, 152);
        ctx.textAlign = 'center'; ctx.fillStyle = '#2ecc71'; ctx.font = 'bold 8px monospace';
        ctx.fillText(isTouchDevice ? 'TAP TO START RUNNING!' : 'SPACE TO START RUNNING!', INTERNAL_W/2, 215);
        return;
    }

    if (state.screen === 'INTRO_FLOOR' || state.screen === 'HIT_PAUSE') {
        drawRect(0, 0, INTERNAL_W, INTERNAL_H, '#000');
        ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.font = 'bold 12px monospace';
        if (state.screen === 'HIT_PAUSE') {
            ctx.fillStyle = '#e74c3c';
            ctx.fillText('WHOOPS!', INTERNAL_W/2, 60);
            ctx.fillStyle = '#fff';
            ctx.font = '7px monospace';
            const words = state.gameOverMessage.split(' ');
            let line = ''; let yPos = 85;
            for(let n = 0; n < words.length; n++) {
                let testLine = line + words[n] + ' ';
                if (testLine.length > 20) { ctx.fillText(line, INTERNAL_W/2, yPos); line = words[n] + ' '; yPos += 10; }
                else line = testLine;
            }
            ctx.fillText(line, INTERNAL_W/2, yPos);
            ctx.fillStyle = '#f1c40f';
            ctx.font = 'bold 9px monospace';
            ctx.fillText(`LIVES REMAINING: ${state.lives}`, INTERNAL_W/2, yPos + 25);
            ctx.fillStyle = '#fff';
            ctx.font = '6px monospace';
            ctx.fillText(isTouchDevice ? 'TAP TO TRY AGAIN' : 'SPACE TO TRY AGAIN', INTERNAL_W/2, 210);
        } else {
            ctx.fillText(`FLOOR ${state.floor}`, INTERNAL_W/2, 100);
            ctx.fillStyle = '#bdc3c7';
            ctx.font = 'bold 8px monospace'; ctx.fillText(config.name, INTERNAL_W/2, 120);
        }
        return;
    }

    if (state.screen === 'PLAY' || state.screen === 'FINISH_SEQ') {
        drawRect(0, 0, INTERNAL_W, INTERNAL_H, config.color);
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        const offset = (Math.floor(state.distance / 10) % 32);
        for(let j=-1; j<9; j++) ctx.fillRect(0, j*32 + offset, INTERNAL_W, 1);
        
        if (state.distance > state.maxDistance - 1000 || state.screen === 'FINISH_SEQ') { 
            drawFinishLine(state.finishLineY); 
            drawDoor(state.doorY); 
        }

        state.pickups.forEach(pk => {
            if (pk.type === 'COFFEE') drawCoffee(pk.x, pk.y);
            else if (pk.type === 'ANNUAL LEAVE') drawLeave(pk.x, pk.y);
            else drawFloppy(pk.x, pk.y);
        });
        state.obstacles.forEach(o => {
            if (o.type === 'MEETING') drawMeeting(o.x, o.y);
            else if (o.type === 'NOTIF') drawNotification(o.x, o.y);
            else drawSlideDeck(o.x, o.y);
        });
        drawPlayer(state.player);

        ctx.textAlign = 'center'; ctx.font = 'bold 8px monospace';
        state.floatingTexts.forEach(ft => {
            ctx.fillStyle = ft.color;
            ctx.globalAlpha = Math.min(1, ft.life * 2);
            ctx.fillText(ft.text, ft.x, ft.y);
            ctx.globalAlpha = 1.0;
        });
    }

    if (state.screen === 'CLEARED') {
        drawRect(0, 0, INTERNAL_W, INTERNAL_H, '#111');
        ctx.fillStyle = 'rgba(255,255,255,0.1)'; ctx.fillRect(10, 45, INTERNAL_W-20, 60);
        ctx.fillStyle = '#2ecc71'; ctx.textAlign = 'center'; ctx.font = 'bold 10px monospace';
        ctx.fillText(`FLOOR ${state.floor} CLEARED!`, INTERNAL_W/2, 65);
        ctx.fillStyle = '#fff'; ctx.font = 'bold 9px monospace';
        ctx.fillText(`BONUS: +${state.floorScore}`, INTERNAL_W/2, 90);
        ctx.fillStyle = '#bdc3c7'; ctx.font = '8px monospace';
        ctx.fillText(isTouchDevice ? 'TAP TO DESCEND' : 'PRESS SPACE TO DESCEND', INTERNAL_W/2, 160);
    }

    if (state.screen === 'WIN') {
        drawRect(0, 0, INTERNAL_W, INTERNAL_H, '#000');
        ctx.fillStyle = '#2ecc71'; ctx.textAlign = 'center'; ctx.font = 'bold 12px monospace';
        ctx.fillText('FREEDOM!', INTERNAL_W/2, 60);
        ctx.fillStyle = '#fff'; ctx.font = '8px monospace';
        ctx.fillText(`FINAL SCORE: ${state.score}`, INTERNAL_W/2, 100);
        ctx.fillStyle = '#f1c40f'; ctx.fillText('AJ IS OUT OF OFFICE', INTERNAL_W/2, 130);
        ctx.fillStyle = '#fff'; ctx.font = '6px monospace';
        ctx.fillText(isTouchDevice ? 'TAP TO REPLAY' : 'PRESS SPACE TO REPLAY', INTERNAL_W/2, 200);
    }

    if (state.screen === 'GAMEOVER') {
        drawRect(0, 0, INTERNAL_W, INTERNAL_H, 'rgba(0,0,0,0.9)');
        ctx.fillStyle = '#e74c3c'; ctx.textAlign = 'center'; ctx.font = 'bold 12px monospace';
        ctx.fillText('GAME OVER', INTERNAL_W/2, 60);
        
        ctx.fillStyle = '#fff'; ctx.font = '7px monospace';
        const words = state.gameOverMessage.split(' ');
        let line = ''; let yPos = 85;
        for(let n = 0; n < words.length; n++) {
            let testLine = line + words[n] + ' ';
            if (testLine.length > 20) { ctx.fillText(line, INTERNAL_W/2, yPos); line = words[n] + ' '; yPos += 10; }
            else line = testLine;
        }
        ctx.fillText(line, INTERNAL_W/2, yPos);
        
        ctx.fillStyle = '#2ecc71'; ctx.font = 'bold 10px monospace';
        ctx.fillText(`FINAL SCORE: ${state.score}`, INTERNAL_W/2, 140);

        ctx.fillStyle = '#bdc3c7'; ctx.font = '8px monospace';
        ctx.fillText(isTouchDevice ? 'TAP TO EXIT TO MENU' : 'SPACE TO EXIT TO MENU', INTERNAL_W/2, 180);
    }

    state.swipeTrail.forEach(pt => {
        ctx.fillStyle = `rgba(255, 255, 255, ${pt.life / 20})`;
        ctx.fillRect(Math.floor(pt.x), Math.floor(pt.y), 2, 2);
    });
}

// --- INPUTS ---

function handleInput() {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    if (state.screen === 'START') { playSound('start'); state.screen = 'HOWTO_PICKUPS'; return; }
    if (state.screen === 'HOWTO_PICKUPS') { playSound('start'); state.screen = 'HOWTO_OBSTACLES'; return; }
    if (state.screen === 'HOWTO_OBSTACLES') { playSound('start'); resetGame(); startFloor(); return; }
    if (state.screen === 'HIT_PAUSE') { playSound('start'); startFloor(false); return; } 
    if (state.screen === 'CLEARED') {
        playSound('start');
        if (state.floor > 1) { state.floor--; startFloor(); }
        else { state.screen = 'WIN'; }
        return;
    }
    if (state.screen === 'GAMEOVER' || state.screen === 'WIN') {
        playSound('start');
        state.screen = 'START';
        return;
    }
}

function resetGame() {
    state.floor = 5;
    state.score = 0;
    state.lives = 3;
}

function startFloor(resetFloorScore = true) {
    state.screen = 'INTRO_FLOOR';
    state.introTimer = 1.5;
    state.distance = 0;
    if (resetFloorScore) state.floorScore = 0;
    state.obstacles = [];
    state.pickups = [];
    state.floatingTexts = [];
    const config = state.floorConfig[state.floor];
    state.maxDistance = config.speed * 20 * 60; 
    state.finishLineY = -200; 
    state.doorY = -500; 
    state.player.x = INTERNAL_W / 2 - 6;
    state.player.y = INTERNAL_H - 60;
    state.player.powerup = null;
    state.player.trail = [];
    state.player.walkSoundTimer = 0;
    lastTime = Date.now();
}

window.addEventListener('keydown', e => {
    state.keys[e.key] = true;
    if (e.code === 'Space' || e.code === 'Enter') { 
        e.preventDefault(); 
        handleInput(); 
    }
});
window.addEventListener('keyup', e => state.keys[e.key] = false);

function getTouchPos(e) {
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches[0];
    return {
        x: (touch.clientX - rect.left) / (rect.width / INTERNAL_W),
        y: (touch.clientY - rect.top) / (rect.height / INTERNAL_H)
    };
}

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (state.screen !== 'PLAY') handleInput();
    else {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        state.touchStart = getTouchPos(e);
    }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (state.screen !== 'PLAY' || !state.touchStart) return;
    const current = getTouchPos(e);
    state.swipeTrail.push({ x: current.x, y: current.y, life: 20 });
    const dx = current.x - state.touchStart.x;
    const dy = current.y - state.touchStart.y;
    const thresh = 10;
    state.keys['ArrowLeft'] = state.keys['ArrowRight'] = state.keys['ArrowUp'] = state.keys['ArrowDown'] = false;
    if (Math.abs(dx) > thresh || Math.abs(dy) > thresh) {
        if (Math.abs(dx) > Math.abs(dy)) state.keys[dx > 0 ? 'ArrowRight' : 'ArrowLeft'] = true;
        else state.keys[dy > 0 ? 'ArrowDown' : 'ArrowUp'] = true;
    }
}, { passive: false });

canvas.addEventListener('touchend', () => {
    state.touchStart = null;
    if (state.screen === 'PLAY') {
        state.keys['ArrowLeft'] = state.keys['ArrowRight'] = state.keys['ArrowUp'] = state.keys['ArrowDown'] = false;
    }
});

function bindBtn(id, key) {
    const b = document.getElementById(id);
    b.addEventListener('touchstart', (e) => { 
        e.preventDefault(); 
        if (audioCtx.state === 'suspended') audioCtx.resume();
        state.keys[key] = true; 
    }, { passive: false });
    b.addEventListener('touchend', (e) => { e.preventDefault(); state.keys[key] = false; }, { passive: false });
}
bindBtn('btn-up', 'ArrowUp'); bindBtn('btn-down', 'ArrowDown');
bindBtn('btn-left', 'ArrowLeft'); bindBtn('btn-right', 'ArrowRight');

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
